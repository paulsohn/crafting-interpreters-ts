import path from 'path'
import fs, { WriteStream } from 'fs'

/// start from 5.3
// https://craftinginterpreters.com/representing-code.html


// type Field = {
//     symbol: string,
//     name: string
// };

// type Grammar = Record<string, Field[]>;
type Grammar = Record<string, string[]>; // className : field[]

// function e(line: string): Field{
//     const splitted = line.split(': ')
//     return {
//         name: splitted[0],
//         symbol: splitted[1]
//     };
// }

// function l(field: Field): string{
//     return field.name + ': ' + field.symbol;
// }

function main(){
    // https://ourcodeworld.com/articles/read/393/how-to-create-a-global-module-for-node-js-properly
    // delete the 0 and 1 argument ( node and script.js )
    var args = process.argv.splice( process.execArgv.length + 1 );

    // console.log(process.argv);
    // console.log(process.execArgv);
    // console.log(args);

    if( args.length != 1 ){
        console.log("Usage: <this file> [output dir]");
        process.exit(64); //EX_USAGE
        return;
    }

    var outputDir = args[0];

    defineAst(outputDir, 'Expr', [], {
        'Assign' : [ 'name: Token', 'value: Expr' ],
        'Binary' : [ 'left: Expr', 'operator: Token', 'right: Expr'  ],
        'Grouping': [ 'expression: Expr' ],
        'Literal' : [ 'value: Primitive' ],
        'Unary' : [ 'operator: Token', 'right: Expr' ],
        'Variable': [ 'name: Token' ],
    });

    defineAst(outputDir, 'Stmt', ['Expr'], {
        'Block': [ 'statements: Stmt[]' ],
        'Expression': [ 'expression: Expr' ],
        'Print': [ 'expression: Expr' ],
        'Var': [ 'name: Token', 'initializer: Expr | null' ],
    });
}

// a metaprogramming.
function defineAst(outputDir: string, baseName: string, dependency: string[], bnf: Grammar){
    var target: string = path.join(outputDir, './' + baseName + '.ts');

    var wstream = fs.createWriteStream(target);

    wstream.write(`// this file is autogenerated by GenerateAst.ts\n`);
    wstream.write(`\n`);
    wstream.write(`import { Token, Primitive } from './Token'\n`);
    for(var className of dependency){
        wstream.write(`import { ${ className } } from './${ className }'\n`);
    }
    wstream.write(`\n`);

    wstream.write(`export abstract class ${baseName} {\n`);
    wstream.write(`    abstract accept<R>(visitor: Visitor<R>): R\n`);
    wstream.write(`}\n`);
    wstream.write(`\n`);

    for(var className in bnf){
        var fields = bnf[className];
        defineType(wstream, baseName, className, fields);
    }

    defineVisitor(wstream, baseName, bnf);

    wstream.close();
}

function defineVisitor(wstream: WriteStream, baseName: string, bnf: Grammar){
    wstream.write(`export interface Visitor<R> {\n`)
    for(var className in bnf){
        // var fields = bnf[className];
        wstream.write(`    visit${ className }${baseName}(${ baseName.toLowerCase() }: ${ className }): R;\n`)
    }

    wstream.write(`}\n`);
    wstream.write(`\n`);
}

function defineType(wstream: WriteStream, baseName: string, className: string, fields: string[]){
    wstream.write(`export class ${className} extends ${baseName} {\n`);

    for(var field of fields){
        wstream.write(`    ${field};\n`);
    }

    wstream.write(`\n`);

    // constructor
    wstream.write(`    constructor(${ fields.join(', ') }){\n`);
    wstream.write(`        super();\n`);
    for(var field of fields){
        var name = field.split(': ')[0];
        wstream.write(`        this.${name} = ${name};\n`);
    }
    wstream.write(`    }\n`);
    wstream.write(`\n`);

    // accept
    wstream.write(`    override accept<R>(visitor: Visitor<R>): R {\n`);
    wstream.write(`        return visitor.visit${className}${baseName}(this);\n`)
    wstream.write(`    }\n`);
    wstream.write(`}\n`);
    wstream.write(`\n`);
}

main();